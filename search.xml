<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JQurey插件写法（1）]]></title>
      <url>http://zxypro.com/2016/07/30/JQurey%E6%8F%92%E4%BB%B6%E5%86%99%E6%B3%95%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="JQuery插件-1"><a href="#JQuery插件-1" class="headerlink" title="JQuery插件(1)"></a>JQuery插件(1)</h1><h2 id="1-插件的类别"><a href="#1-插件的类别" class="headerlink" title="1.插件的类别"></a>1.插件的类别</h2><p>在jQuery中要使用一个插件，一般有两种形式：</p>
<p>类级别：例如 $.myPlugin()</p>
<p>对象级别：例如$(‘#node’).myPlugin()</p>
<p>类级别插件可以理解为拓展 jQuery 类，即给 jQuery 添加新的全局函数，典型的例子就是$.ajax()这个函数。JQ的全局函数就是属于JQ命名空间的函数。另一种是对象级别的插件，即作用于指定的JQ对象，典型的例子$(‘.msg’).show()。</p>
<a id="more"></a>
<h3 id="类级别JQ插件的开发"><a href="#类级别JQ插件的开发" class="headerlink" title="类级别JQ插件的开发"></a>类级别JQ插件的开发</h3><h4 id="1-原始写法"><a href="#1-原始写法" class="headerlink" title="1.原始写法"></a>1.原始写法</h4><p>一般在项目中我们会引入一个 js 文件，里面存放了所有的 js 代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"http://www.lovelucy.info/all.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>只要写一些函数简单地放在文件里，就算是一个模块，直接调用就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function m1()&#123;</div><div class="line">　　//...</div><div class="line">&#125;</div><div class="line">function m2()&#123;</div><div class="line">   //...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种方法缺陷很明显，就是污染了全局空间，无法保证不与其他模块发生变量名冲突，而且方法成员之间看不出直接关系</p>
<h4 id="2-扩展写法"><a href="#2-扩展写法" class="headerlink" title="2.扩展写法"></a>2.扩展写法</h4><p>使用 jQuery.extend(object) 来扩展 jQuery 类本身，可以理解为 jQuery 添加静态方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$.extend(&#123;</div><div class="line">　　addMethod : <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;<span class="keyword">return</span> a + b;&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// $.addMethod(1, 2); //return 3</span></div></pre></td></tr></table></figure></p>
<h4 id="3-简单写法"><a href="#3-简单写法" class="headerlink" title="3.简单写法"></a>3.简单写法</h4><p>给 jQuery 添加一个全局函数，只需如下定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jQuery.foo = function() &#123;</div><div class="line">    alert(&apos;test&apos;);</div><div class="line">    // other code...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样就能直接用了：jQuery.foo() 或者 $.foo() 。</p>
<h4 id="4-使用命名空间"><a href="#4-使用命名空间" class="headerlink" title="4.使用命名空间"></a>4.使用命名空间</h4><p>虽然上面的 2 种写法相对于原始写法要干净很多，减少了在全局空间冲突的概率，但是在 jQuery 命名空间中，仍然不可避免某些函数或变量名可能和其他 jQuery 插件冲突。因此我们习惯再封装一层，将一些方法封装到另一个自定义的命名空间<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">jQuery.myPlugin = &#123;</div><div class="line">    foo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">'test'</span>);</div><div class="line">    &#125;,</div><div class="line">    bar:<span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</div><div class="line">        alert(<span class="string">'test "'</span> + param + <span class="string">'".'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// $.myPlugin.foo();</span></div><div class="line"><span class="comment">// $.myPlugin.bar('hello');</span></div></pre></td></tr></table></figure></p>
<p>采用命名空间的函数仍然是全局函数，使用独立的插件名我们可以避免命名空间内函数的冲突。</p>
<h3 id="三-对象级别的JQ插件开发"><a href="#三-对象级别的JQ插件开发" class="headerlink" title="三 对象级别的JQ插件开发"></a>三 对象级别的JQ插件开发</h3><p>大部分 jQuery 插件都是对象级别的，开发一个对象级别插件会遇到闭包这个概念，简单起见先只看闭包的表现形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function($)&#123;  </div><div class="line">    // your codes  </div><div class="line">&#125;)(jQuery);</div></pre></td></tr></table></figure>
<h4 id="1-扩展写法"><a href="#1-扩展写法" class="headerlink" title="1.扩展写法"></a>1.扩展写法</h4><p>给 jQuery 对象添加方法，就是对 jQuery.prototype 进行扩展，为 jQuery 类添加成员方法，需要用到 jQuery.fn.extend(object); 。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$.fn.extend(&#123; </div><div class="line">    getInputText:function()&#123; </div><div class="line">        $(this).click(function()&#123; </div><div class="line">            alert($(this).val()); </div><div class="line">        &#125;); </div><div class="line">    &#125; </div><div class="line">&#125;);</div><div class="line">//$(&quot;#username&quot;).getInputText();</div></pre></td></tr></table></figure>
<h4 id="2-通用写法"><a href="#2-通用写法" class="headerlink" title="2.通用写法"></a>2.通用写法</h4><p>对象级别的插件也可以这样定义 $.fn.myPlugin = function(){}，同样的，和类级别相比多了一个 fn。<br>一个通用的对象级别插件框架——<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123; </div><div class="line">    $.fn.myPluginName = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123; </div><div class="line">        <span class="keyword">var</span> defaults = &#123;&#125; <span class="comment">//各种属性和参数</span></div><div class="line">        <span class="keyword">var</span> options = $.extend(defaults, options); </div><div class="line">        <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </div><div class="line">            <span class="comment">//插件的实现代码</span></div><div class="line">        &#125;); </div><div class="line">    &#125;; </div><div class="line">&#125;)(jQuery);</div></pre></td></tr></table></figure></p>
<p>$.extend(defaults, options) 通过合并 defaults 和 options 来扩展默认参数，实现插件接受外部 options 参数的功能。于是我们就可以见到这样的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;#myDiv&apos;).hilight(&#123;</div><div class="line">    foreground: &apos;blue&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="3-改进的通用写法"><a href="#3-改进的通用写法" class="headerlink" title="3. 改进的通用写法"></a>3. 改进的通用写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function($)&#123; </div><div class="line">    $.fn.myPluginName = function(options)&#123;</div><div class="line">        var options = $.extend(&#123;&#125;, $.fn.myPluginName.defaults, options);</div><div class="line">        this.each(function()&#123;</div><div class="line">            //插件的实现代码</div><div class="line">        &#125;); </div><div class="line">    &#125;;</div><div class="line">    // 暴露的默认参数</div><div class="line">    $.fn.myPluginName.defaults = &#123;&#125;;</div><div class="line">&#125;)(jQuery);</div></pre></td></tr></table></figure>
<p>于是我们就可以见到这样使用的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$.fn.hilight.defaults.foreground = &apos;blue&apos;;</div><div class="line">$(&apos;#myDiv&apos;).hilight();</div></pre></td></tr></table></figure></p>
<p>覆盖默认的配置就只需要调用一次，而不必在每次调用插件时都传递参数。是否需要传递参数，在不同的场景下可以灵活处理，两者的使用可以结合起来。</p>
<p>更高级的插件写法还包括暴露一些函数给使用者，让他们可以覆盖。另一方面，也可以保持私有函数的私有性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vue学习（1）]]></title>
      <url>http://zxypro.com/2016/07/30/vue%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="vue学习"><a href="#vue学习" class="headerlink" title="vue学习"></a>vue学习</h1><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>因为 JavaScript 的限制，Vue.js 不能检测到下面数组变化：</p>
<ol>
<li>直接用索引设置元素，如 vm.items[0] = {}；</li>
<li>修改数据的长度，如 vm.items.length = 0。</li>
</ol>
<p>为了解决问题 (1)，Vue.js 扩展了观察数组，为它添加了一个 $set() 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 与 `example1.items[0] = ...` 相同，但是能触发视图更新</span></div><div class="line">example1.items.$set(<span class="number">0</span>, &#123; childMsg: <span class="string">'Changed!'</span>&#125;)</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>至于问题 (2)，只需用一个空数组替换 items。</p>
<h2 id="方法与事件处理"><a href="#方法与事件处理" class="headerlink" title="方法与事件处理"></a>方法与事件处理</h2><p>event是原生的dom事件，event.target可以拿到原生的dom节点</p>
]]></content>
    </entry>
    
  
  
</search>
